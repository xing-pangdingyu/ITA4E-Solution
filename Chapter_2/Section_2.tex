\documentclass[12pt,reqno]{amsart}
%\documentclass[../Solutions_Introduction_to_Algorithms.tex]{subfiles}
\usepackage{amsmath,amsfonts,amscd,amssymb,epsf,color,enumerate,graphicx,url}
\usepackage{algorithm, algorithmic}
\usepackage{forest, tikz, xcolor}
\usepackage{parskip}
\usetikzlibrary{matrix, positioning}
\usetikzlibrary{positioning,arrows.meta}
\setlength{\oddsidemargin}{-0.2in}%
\setlength{\evensidemargin}{-0.2in}%
\setlength{\textwidth}{6.6in}%
\setlength{\topmargin}{-0.5in}%
 \setlength{\textheight}{9.5in}%
 \definecolor{orange}{rgb}{1,0.5,0}
 \pagestyle{plain}
\linespread{1.3}
\usepackage[small]{caption}
\newcommand{\pa}{\partial}
\newcommand{\va}{\vspace{0.4cm}}
\newcommand{\di}{\displaystyle}
\newcommand{\disp}{\displaystyle}


% turn on \answertrue to show the solution
% turn on \answerfalse to hide the solution
\newif\ifanswer
\answertrue
%\answerfalse



\begin{document}
\noindent {\footnotesize Introduction to Algorithms}\hspace{10.5cm} {\footnotesize Solutions}

\vspace{0.5cm}
\hspace{5.5cm}\textbf{\large Exercises in Section 2.2}
\vspace{0.5cm}

\begin{enumerate}[1.]

\item Express the function $n^3/1000 + 100n^2 - 100n + 3$ in terms of $\Theta$-notation.
\vspace{0.5cm}

\ifanswer
\noindent {\bf Solution}

$n^3/1000 + 100n^2 - 100n + 3 = \Theta(n^3)$.

\vspace{1cm}



\item Consider sorting $n$ numbers stored in array $A[1\!:\!n]$ by first finding the smallest
element of $A[1\!:\!n]$ and exchanging it with the element in $A[1]$. Then find the
smallest element of $A[2\!:\!n]$, and exchange it with $A[2]$. Then find the smallest
element of $A[3\!:\!n]$, and exchange it with $A[3]$. Continue in this manner for the
first $n-1$ elements of $A$. Write pseudocode for this algorithm, which is known as
\emph{selection sort}. What loop invariant does this algorithm maintain? Why does it
need to run for only the first $n-1$ elements, rather than for all $n$ elements? Give
the worst-case running time of selection sort in $\Theta$-notation. Is the best-case
running time any better?

\vspace{0.5cm}

\ifanswer
\noindent {\bf Solution}

\begin{algorithm}
    \caption{\textsc{Selection-Sort}$(A, n)$}
    \begin{algorithmic}[1]
        \FOR{$i = 1$ to $n - 1$}
            \STATE $min = i$
            \FOR{$j = i + 1$ to $n$}
                \IF{$A[j] < A[min]$}
                    \STATE $min = j$
                \ENDIF
            \ENDFOR
            \STATE $temp = A[i]$
            \STATE $A[i] = A[min]$
            \STATE $A[min] = temp$
        \ENDFOR
        \RETURN $A$
    \end{algorithmic}
\end{algorithm}

Both the worst case running time and the best case running time are $\Theta(n^2)$.

\vspace{1cm}



\item Consider linear search again (see Exercise 2.1-4). How many elements of the input array need to be checked on average, assuming that the element being searched for is equally likely to be any element in the array? How about in the worst case? Using $\Theta$-notation, give the average-case and worst-case running times of the linear search. Justify your answers.
\vspace{0.5cm}

\ifanswer
\noindent {\bf Solution}

If each element is equally likely to be any element in the array, then the average number of elements checked is $(n + 1)/2$. In the worst case, the number of elements checked is $n$. Therefore, both the average-case and worst-case running times are $\Theta(n)$.

\vspace{1cm}



\item How can you modify any sorting algorithm to have a good best-case running time?
\vspace{0.5cm}

\ifanswer
\noindent {\bf Solution}

Just add a check to see if the array is already sorted.
\vspace{1cm}


\end{enumerate}

\end{document}



